### A. 构造数字
#### 算法一
暴力枚举 $n$ 的倍数，可以得到 $30\%$ 的分数。

#### 算法二
为 $n$ 的倍数可以描述为模 $n$ 为 $0$。于是可以直接 bfs 枚举数字（这样可以保证从小到大得到每一个数字），当得到一个数 $x$，存在另一个已经得到的数 $x'$ 使得 $x \equiv x' \pmod n$ 则 $x$ 没必要继续加入队列。

所以最多 $n$ 个元素入队，通过记录每个数是怎么得到的即可输出答案。

### B. 选择石头
#### 算法一
直接枚举取石头的顺序。

#### 算法二
如果把所有数都减去 $b_i$，则答案不会变，也就是对于一堆石头，先手选会获得 $a_i - b_i$ 分，后手选会得 $0$ 分。

则肯定是贪心选最大的。而若 $a_i - b_i \geq 0$，一定会抢着选，若 $a_i - b_i < 0$，一定是等着后手选。

于是会先选 $a_i - b_i \geq 0$，然后再选这些剩下的 $0$。

然后对于 $a_i < b_i$ 的，当负的被选后，剩下的 $0$ 会被立马选。

于是被选的顺序就被确定了，按照值排序后 rank 模 $4$ 或 $2$ 的顺序有不同的贡献。

对此用值域线段树维护就可以了。

### C. 打通地牢
#### 算法一
直接枚举打的顺序。

#### 算法二
使用 DP $f_{l, r}$ 来计算走的过程中最小值最大是多少。

#### 算法三
会发现，在一端往前走的时候，另一端尽量不要吃负的。这启发我们，除了最后一次移动端点完成环以外，其他时候端点的移动都是从前缀最大值移动到一个新的前缀最大值（也就是固定一个端点的前缀最大值，看看另一端点能走多远，能不能到一个新的前缀最大值）。这样交替走，如果走不动了就说明无法吃完。那么二分答案即可。

### D. 修剪树枝
#### 算法一
直接枚举选取的集合，通过 dfs 算留下的树有多大。

#### 算法二
树的节点数，可以将关键点按 dfs 序排序后，拆成相邻点距离之和来计算。

使用 DP，因为是计算树大小和标号的乘积，于是可以对每个点 $u$，记录 $f_{u, 01, 01}$ 四个 $dp$ 数组来表示 $u$ 作为目前 $dfs$ 序最大的点时：
1. 方案数。
2. 对于所有方案距离和的和。
3. 对于所有方案标号和的和。
4. 对于所有方案，距离和与乘积和的和。

$O(n^2)$ 即可 DP 完。

#### 算法三
这个 DP 的瓶颈在于枚举 lca 来算距离。可以使用重链剖分来枚举 lca 所在的重链。这样就可以通过单点加区间修改来优化 DP。复杂度 $O(n \log^2 n)$。

#### 算法四
很容易通过类似启发式合并的做法，先算轻链再算重链，把轻链的贡献直接暴力计算。这样要求 dfs 过程中最后访问重儿子。

#### 算法五
由线性性，其实可以直接枚举每对 $x < y$ 带来的贡献：

拆出式子直接在 lca 处计算贡献。

#### 算法六
其实直接计算一个路径上的点的贡献即可。比算法五好写。

具体就是要么子树里选两个点，要么在子树内选一个子树外选一个。